Specific rules:
Вы заметите, что в этом конкретном предмете многие проблемы, которые вас просят решить, могут быть решены НЕ с использованием стандартных контейнеров и НЕ с использованием стандартных алгоритмов.
Однако их использование и является целью, и если вы не приложите все усилия для использования стандартных контейнеров и алгоритмов там, где это уместно, вы получите очень плохую оценку,
какой бы функциональной ни была ваша работа. Пожалуйста, не будь таким ленивым

ex00:
Легко начать с правильной ноги ...
Создайте шаблонную функцию easyfind, основанную на типе T, которая принимает T и int.
Предположим, что T является контейнером int, и найдите первое вхождение второго параметра в первом параметре.
Если его не удается найти, обработайте ошибку либо с помощью исключения, либо с помощью возвращаемого значения ошибки. Возьмите идеи из того, как работают стандартные контейнеры.
Конечно, вы предоставите основную функцию, которая тщательно ее протестирует.


ex01:
Создайте класс, в котором вы можете хранить N int. N будет беззнаковым целым числом и будет передано конструктору в качестве его единственного параметра.
У этого класса будет функция для хранения единственного числа (addNumber), которое будет использоваться для его заполнения. 
Попытка добавить новый номер, если в объекте уже хранится N из них, является ошибкой и должна привести к исключению.
Теперь вы создадите две функции, ShortSpan и LongestSpan, которые будут определять соответственно самый короткий и самый длинный промежуток между всеми числами, содержащимися в объекте, и возвращать его. 
Если числа не сохранены или только одно, диапазона для поиска нет, и вы выдадите исключение.
Ниже приведен (слишком короткий) пример основной тестовой программы и связанных с ней выходных данных. Конечно, ваш main будет более тщательным, чем это. 
Вы должны протестировать как минимум 10 000 номеров. Больше было бы хорошо. 
Также было бы очень хорошо, если бы вы могли складывать числа, передавая диапазон итераторов, что позволило бы избежать раздражения, связанного с тысячами вызовов addNumber ...


ex02:
Теперь, когда закуски готовы, давайте займемся отвратительными вещами.
Контейнер std :: stack ОЧЕНЬ крутой, но это один из немногих контейнеров STL, который НЕ повторяется. Это очень плохо. 
Но зачем с этим мириться, если мы можем просто сыграть в Бога и разделать его, чтобы добавить что-то, что нам нравится?
Вы вставите эту способность в контейнер std :: stack, чтобы исправить эту серьезную несправедливость.
Создайте класс MutantStack, который будет реализован в терминах std :: stack и предложит все его функции-члены, только он также будет предлагать итератор.
Ниже приведен пример кода, вывод которого должен быть таким же, как если бы мы заменили MutantStack, например, на std :: list. Вы, конечно же, предоставите тесты для всего этого в своей основной функции.