ex 00

Сначала создайте класс зомби. У зомби есть личное имя, и они могут объявлять о себе так:
<имя> BraiiiiiiinnnzzzZ ...
Да, объявить (void) - это функция-член. Также добавьте отладочное сообщение в деструктор, включая имя Зомби.
После этого напишите функцию, которая создаст зомби, назовите ее и вернет для использования где-нибудь еще в вашем коде. Прототип функции:
Зомби * newZombie (std :: string name);
Вам также нужно будет написать другую функцию, которая создаст зомби и заставит его объявить о себе. Прототип функции:
void randomChump (std :: string name);
Теперь суть упражнения: ваши зомби должны быть уничтожены в подходящее время (когда они больше не нужны). Они должны быть размещены в стеке или куче, в зависимости от их использования: иногда уместно иметь их в стеке, в других случаях куча может быть лучшим выбором.

ex 01

Повторно используя класс зомби, теперь мы собираемся создать орду зомби!
Напишите функцию, которая принимает целое число N. При вызове она выделяет N объектов Zombie.
Он должен выделить все N объектов Zombie за одно выделение. Затем он должен инициализировать каждого зомби, дав каждому имя. Наконец, он должен вернуть указатель на первого зомби. Прототип функции выглядит следующим образом:
Зомби * zombieHorde (int N, std :: string name);
Отправьте main, чтобы проверить, что ваша функция zombieHorde работает должным образом. Вы можете сделать это, вызвав анонс () для каждого из Зомби. Не забудьте удалить ВСЕХ зомби, когда они вам больше не нужны.

ex 02

Составьте программу, в которой вы создадите строку, содержащую «HI THIS IS BRAIN».
Создайте stringPTR, который является указателем на строку; и stringREF, который является ссылкой на строку.
Теперь отобразите адрес в памяти строки. Затем отобразите адрес строки с помощью stringPTR и stringREF.
Наконец, отобразите строку с помощью указателя и, наконец, отобразите ее с помощью ссылки.
Все, никаких фокусов. Цель этого упражнения - развеять мифы о ссылках. Это не что-то совершенно новое, это просто еще один синтаксис того, что вы уже знаете: адресов. Даже есть какие-то крошечные-маленькие-мелкие детали.

ex 03

Translation results
Создайте класс Weapon, который имеет строку типа и метод getType, который возвращает константную ссылку на эту строку. Конечно, у него также есть setType!
Теперь создайте два класса, HumanA и HumanB, у каждого из которых есть Weapon, имя и функция attack (), которая отображает:
NAME атакует своим WEAPON_TYPE
HumanA и HumanB почти одинаковы; есть только две крошечные-маленькие-незначительные детали:
• В то время как HumanA принимает Оружие в своем конструкторе, HumanB - нет.
• HumanB не всегда может иметь оружие, но HumanA ВСЕГДА будет вооружен. 
Сделайте так, чтобы следующий код в обоих тестовых случаях производил атаки «грубой клюшкой с шипами», ЗАТЕМ «другим типом клюшки»:
...
В каком случае уместно хранить Оружие как указатель? А в качестве ссылки?
Почему?
Это вопросы, которые вы должны задать себе перед тем, как приступить к выполнению этого упражнения.

ex 04

Создайте программу с именем replace, которая принимает имя файла и две строки, назовем их s1 и s2, которые НЕ пусты.
Он откроет файл и запишет его содержимое в FILENAME.replace после замены каждого вхождения s1 на s2.
Разрешены все функции-члены класса std :: string, кроме replace. Используйте их с умом!
Конечно, вы будете обрабатывать ошибки как можно лучше. Не используйте функции манипулирования файлами C, потому что это было бы жульничеством, а жульничество - плохо, понимаешь?
Вы предоставите несколько тестовых файлов, чтобы показать, что ваша программа работает.

ex 05

Вы знаете Карен? Все мы, не так ли? Если вы этого не сделаете, вот какие комментарии делает Карен:
• Уровень «DEBUG»: сообщения на этом уровне содержат обширную контекстную информацию.
В основном они используются для диагностики проблем. Пример: «Мне нравится получать больше бекона для моего бургера 7XL-двойной-сыр-тройной-соленый-специальный-кетчуп. Мне это просто нравится!»
• Уровень «ИНФОРМАЦИЯ»: эти сообщения содержат некоторую контекстную информацию, которая помогает отслеживать выполнение в производственной среде. Пример: «Я не могу поверить, что добавление дополнительного бекона стоит больших денег. Вы не положили достаточно! Если бы вы это сделали, мне бы не пришлось просить об этом!»
• Уровень «ПРЕДУПРЕЖДЕНИЕ»: предупреждающее сообщение указывает на потенциальную проблему в системе. Система способна справиться с проблемой самостоятельно или в любом случае продолжить ее решение. Пример: «Я думаю, что заслуживаю получить еще немного бекона бесплатно. Я приезжаю сюда много лет, а вы только начали здесь работать в прошлом месяце».
• Уровень «ОШИБКА»: сообщение об ошибке указывает на серьезную проблему в системе. Проблема обычно не устраняется и требует ручного вмешательства. Пример:
«Это недопустимо, я хочу поговорить с менеджером сейчас».
Мы собираемся автоматизировать Карен, она всегда говорит одно и то же. Вам необходимо создать класс с именем Karen, который будет содержать следующие частные функции-члены:
• недействительная отладка (недействительна);
• недействительная информация (недействительна);
• недействительное предупреждение (недействительно);
• недействительная ошибка (недействительна);
Карен также должна иметь общедоступную функцию, которая вызывает частные функции в зависимости от уровня, переданного в качестве параметра. Прототип функции:
недействительная жалоба (уровень std :: string);
Цель этого упражнения - использовать указатели на функции-члены. Это не предложение, Карен должна жаловаться, не используя лес if / elseif / else, она не сомневается и не думает дважды!
Отправьте основной файл, чтобы проверить, на что Карен часто жалуется. Ничего страшного, если вы хотите использовать жалобы, которые мы приводим в качестве примера.

ex 06

Мы собираемся внедрить систему фильтрации, важно ли то, что говорит Карен, или нет, потому что иногда мы не хотим обращать внимание на все, что говорит Карен.
Вы должны написать программу karenFilter, которая будет получать в качестве параметра уровень журнала, который вы хотите прослушивать, и отображать всю информацию, которая находится на этом уровне или выше. Например:
$> ./karenFilter "ВНИМАНИЕ"
[ ПРЕДУПРЕЖДЕНИЕ ]
Думаю, я заслуживаю того, чтобы получить еще немного бекона бесплатно.
Я приезжаю сюда много лет, а вы только начали здесь работать в прошлом месяце.
[ ОШИБКА ]
Это недопустимо, я хочу поговорить с менеджером сейчас.
$> ./karenFilter "Не знаю, насколько я устал сегодня ..."
[Вероятно, жалуется на незначительные проблемы]
Есть много способов отфильтровать Карен, но один из лучших - ВЫКЛЮЧИТЬ ее;)
Вы должны использовать и, возможно, обнаружить в этом упражнении оператор switch.