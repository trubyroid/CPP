Бонус: В каждом упражнении любая ситуация наложения решается определенным составом. Оценка проверит, соответствует ли ваш выбор ожидаемому составу.

ex00:
Напишите программу, которая принимает строковое представление буквального значения C ++ (в его наиболее распространенной форме) в качестве параметра.
Этот литерал должен принадлежать к одному из следующих скалярных типов: char, int, float или double. Будет использоваться только десятичное представление.
Примеры буквальных значений char: 'c', 'a' ... Для упрощения обратите внимание, что:
неотображаемые символы не могут быть переданы в качестве параметра вашей программе, и если преобразование в char не отображается, выведите уведомление вместо этого.
Примеры буквальных значений int: 0, -42, 42 ...
Примеры значений литералов с плавающей запятой: 0.0f, -4.2f, 4.2f ... Вы также можете принять эти псевдолитералы, как вы знаете, для науки: -inff, + inff и nanf.
Примеры значений двойных литералов: 0,0, -4,2, 4,2 ... Вы также можете принять эти псевдолитералы, как вы знаете, для развлечения: -inf, + inf и nan.
Ваша программа должна определить тип литерала, получить этот литерал правильного типа (чтобы он больше не была строкой),
затем явно преобразовать его в каждый из трех других типов и отобразить результаты с использованием того же форматирования, что и ниже.
Если преобразование не имеет смысла или выходит за рамки, укажите, что преобразование невозможно. 
Вы можете включить любой заголовок, необходимый для обработки числовых ограничений и специальных значений.
examples:
./convert 0
char: Non displayable
int: 0
float: 0.0f
double: 0.0
./convert nan
char: impossible
int: impossible
float: nanf
double: nan
./convert 42.0f
char: '*'
int: 42
float: 42.0f
double: 42.0

ex01:
Напишите функцию «uintptr_t serialize (Data * ptr);». Эта функция вернет параметр в целочисленном типе.
Напишите функцию «Data * deserialize (uintptr_t raw);». Эта функция вернет необработанные данные, созданные вами с помощью «сериализации», в структуру данных.
Оберните эти две функции в программу, которая доказывает, что все работает так, как задумано.
Вы должны создать допустимую структуру данных.
Возьмите адрес данных, используйте сериализацию на нем.
Отправьте возвращаемое значение в deserialize.
Убедитесь, что возвращаемое значение равно первому указателю.
Не забудьте указать используемую вами структуру данных.


ex02:
Создайте класс Base, который имеет только общедоступный виртуальный деструктор. Создайте три пустых класса A, B и C, которые публично наследуют от Base.
Напишите функцию «Base * generate (void);» который случайным образом создает экземпляры A, B или C и возвращает экземпляр как базовый указатель.
Не стесняйтесь использовать что угодно для случайности.
Напишите функцию "void identify (Base * p);" который отображает «A», «B» или «C» в соответствии с реальным типом p.
Напишите функцию "void identify (Base & p);" Вы никогда не должны использовать указатель внутри этой функции. который отображает «A», «B» или «C» в соответствии с реальным типом p.
Оберните эти функции в программу, которая доказывает, что все работает по назначению.
<typeinfo> запрещено. 

