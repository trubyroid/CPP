ex00:
Обратите внимание, что классы исключений не обязательно должны иметь ортодоксальную каноническую форму.
Каждый другой класс должен быть написан таким образом.
Сегодня мы собираемся создать искусственный кошмар офисов, коридоров, форм и очередей. Звучит весело? Нет? Очень жаль.
Во-первых, мы начнем с мельчайшего винтика огромной бюрократической машины: бюрократа.
У него должно быть постоянное имя и оценка в диапазоне от 1 (максимально возможное) до 150 (минимально возможное).
 Любая попытка создать бюрократа с недопустимой оценкой должна вызывать исключение, которое будет либо Bureaucrat :: GradeTooHighException, либо
Бюрократ :: GradeTooLowException.
Вы предоставите геттеры для обоих этих атрибутов (getName и getGrade) и две функции для увеличения или уменьшения оценки.
 Обе эти функции вызовут те же исключения, что и раньше, если оценка станет слишком высокой или слишком низкой. Помните, 1-й класс - самый высокий,
150 - это самый низкий уровень, поэтому повышение оценки на 3 дает вам 2 балла ...
Выбрасываемые вами исключения должны быть перехвачены блоком, например:

Вы предоставите перегрузку оператора << для ostream, который выводит что-то вроде <name>, уровень бюрократа <grade>.
Конечно, вы предоставите основную функцию, чтобы доказать, что вы все это сделали хорошо.

ex01:
Теперь, когда у нас есть бюрократы, лучше пусть они чем-нибудь занимаются своим временем.
Что может быть лучше, чем стопка заполненных бланков?
Создайте класс формы. У него есть имя, логическое значение, указывающее, подписан ли он (в начале это не так), оценка, необходимая для его подписания, и оценка, необходимая для его выполнения.
Имя и оценки постоянны, и все эти атрибуты являются частными (не защищенными).
Оценки подчиняются тем же ограничениям, что и в Бюрократе, и исключения будут выброшены, если любое из них выходит за пределы, Form :: GradeTooHighException и
Форма :: GradeTooLowException.
Как и раньше, создайте геттеры для всех атрибутов и перегрузку оператора << в ostream, который полностью описывает состояние формы.
Вы также добавите функцию beSigned, которая принимает бюрократа и подписывает форму, если оценка бюрократа достаточно высока.
 Всегда помните, что оценка 1 лучше, чем оценка 2. Если оценка слишком низкая, генерируйте исключение Form :: GradeTooLowException.
Также добавьте в Бюрократ функцию signForm.
 Если подписание прошло успешно, он напечатает что-то вроде «<бюрократ> подписывает <форму>», в противном случае он напечатает что-то вроде «<бюрократ> не может подписать <форму>, потому что <причина>».
Добавьте все, что нужно для проверки, в свой main.

ex02:
Теперь, когда у вас есть базовые формы, вы создадите несколько форм, которые действительно что-то делают.
Создайте несколько конкретных форм:
• ShrubberyCreationForm (обязательные оценки: знак 145, exec 137). 
Действие: Создайте файл с именем <target> _shrubbery и напишите в него деревья ASCII в текущем каталоге.
• RobotomyRequestForm (обязательные оценки: знак 72, выполнение 45). 
Действие: издает шум при бурении и сообщает нам, что <цель> успешно роботизировалась в 50% случаев. В противном случае сообщите нам, что это сбой.
• PresidentialPardonForm (обязательные оценки: знак 25, класс 5). Действие: Сообщает нам, что <цель> помилована Зафодом Библброксом.
Все они должны будут принимать в своем конструкторе только один параметр, который будет представлять цель формы. 
Например, «домашний», если вы хотите посадить кусты в домашних условиях. Помните, что атрибуты формы должны оставаться закрытыми и находиться в базовом классе.
Теперь вам нужно добавить метод execute (Bureaucrat const & executor) const к базовой форме и реализовать метод,
 выполняющий действие формы во всех конкретных формах. Вы должны убедиться, что форма подписана и что бюрократ, пытающийся заполнить форму,
имеет достаточно высокую оценку, иначе вы создадите соответствующее исключение.
Независимо от того, хотите ли вы выполнить эти проверки в каждом конкретном классе или выполнить регистрацию в базовом классе,
 тогда вызов другого метода для выполнения действия зависит от вас, но один способ лучше, чем другой. В любом случае базовая форма должна быть абстрактным классом.
Завершите это, добавив к бюрократу функцию executeForm (Form const & form). Он должен попытаться выполнить форму,
 и в случае успеха вывести что-то вроде <бюрократ> выполняет <форму>. Если нет, напечатайте явное сообщение об ошибке.
Добавьте все, что вам нужно, в свой основной, чтобы проверить, что все работает.

ex03:
Поскольку заполнение форм - это достаточно утомительно, было бы жестоко просить наших бюрократов писать их полностью самостоятельно. Нет, это сделает стажер.
Вы собираетесь создать класс Intern. У стажера нет ни имени, ни степени, ни каких-либо определяющих характеристик, мы заботимся только о том, чтобы он выполнял свою работу.
У стажера есть одна важная вещь - функция makeForm. Требуется две строки, первая из которых представляет имя формы, а вторая - цель для формы.
Он вернет в качестве указателя на форму указатель на любой конкретный класс формы, представленный первым параметром, инициализированный вторым параметром. 
На стандартный вывод будет выведено что-то вроде «Intern created <form>». Если оно использует худший метод, например:
if / elseif / elseif / else ветвления или другие уродливые вещи, подобные этому, они не будут приняты во время оценки. Если запрошенная форма неизвестна, выведите явное сообщение об ошибке.
Например, при этом будет создана форма RobotomyRequestForm, нацеленная на «Бендер»:

Ваше главное, конечно же, все это протестировать.