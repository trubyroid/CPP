ex00:
Для каждого упражнения ваша главная должна все проверять.
Конструкторы и деструкторы каждого класса должны иметь специфический вывод.
Создайте простой и полный базовый класс Animal.
Класс животных получил один защищенный атрибут:
• тип std :: string;
Создайте класс Dog, унаследованный от Animal.
Создайте класс Cat, унаследованный от Animal.
(для класса животных тип можно оставить пустым или присвоить любое значение).
Каждый класс должен указать свое имя в поле Тип, например:
Тип класса Dog должен быть инициализирован как «Dog».
Каждое животное должно уметь использовать метод makeSound ().
Этот метод отобразит соответствующее сообщение на стандартных выходных данных в зависимости от класса.

Это должно вывести конкретный makeSound класса Dog и cat, а не животного.
Чтобы быть уверенным, вы создадите класс WrongCat, который наследует класс WrongAnimal, который будет выводить WrongAnimal makeSound () при тестировании в тех же условиях.


ex01
Вы будете повторно использовать классы Ex00.
Создайте один класс под названием Brain.
Мозг будет содержать массив из 100 std :: string, называемый идеями.
Теперь у собак и кошек будет атрибут private Brain *.
Не у каждого животного есть мозг!
После создания Собака и Кошка инициализируют свой Мозг * новым Мозгом ();
При уничтожении Собака и Кошка удаляют свой Мозг.
Ваш main создаст и заполнит массив животных, половина из которых будет собакой, а другая половина - кошкой.
Перед выходом ваш main будет перебирать этот массив и удалять все Animal.
Вы должны удалить напрямую Cat and Dog as an Animal.
Копия Кошки или Собаки должна быть «глубокой».
Ваш тест должен показать, что копии глубокие!
Конструкторы и деструкторы каждого класса должны иметь специфический вывод.
Должны быть вызваны соответствующие деструкторы.

ex02
В конце концов, обычное животное не имеет смысла.
Например, он не издает звука!
Чтобы избежать ошибок в будущем, класс животных по умолчанию не должен быть инстанцируемым.
Исправьте класс Animal, чтобы никто не создал его по ошибке.
Остальное должно работать как раньше.


ex03
В C ++ 98 (даже в C ++ 20) нет интерфейса, но принято называть чистый абстрактный класс интерфейсом. Итак, в этом последнем упражнении давайте попробуем интерфейсы и подведем итоги!
Завершите определение следующего класса AMateria и реализуйте необходимые функции-члены.
Создайте конкретную Materias Ice and Cure. Их типом будет их имя в нижнем регистре («лед» для льда и т. Д.).
Их метод clone (), конечно же, вернет новый экземпляр настоящего типа Материи.
Что касается использования метода (ICharacter &), он будет отображать:
• Лед: «* стреляет ледяной молнией в ИМЯ *»
• Cure: «* лечит раны NAME *»
(Конечно, замените NAME на имя символа, указанного в качестве параметра.)
При назначении Материи другой, копирование типа не делает
смысл...
Создайте класс Character, который будет реализовывать следующий интерфейс:

Персонаж обладает инвентарем не более 4 Материей, пустых в начале. Он будет использовать Материю в слотах с 0 по 3 в указанном порядке.
В случае, если мы попытаемся оснастить Материю в полном инвентаре или использовать / снять несуществующую Материю, ничего не предпринимайте.
Метод unquip НЕ ДОЛЖЕН удалять Материю!
Метод use (int, ICharacter &) должен будет использовать Materia в слоте idx и передавать target в качестве параметра методу AMateria :: use.
Конечно, вы должны иметь возможность поддерживать ЛЮБУЮ материю в инвентаре персонажа.
У вашего персонажа должен быть конструктор, принимающий его имя в качестве параметра. Копирование или присвоение Персонажа, конечно, должно быть глубоким. Старая Материя Персонажа должна быть удалена. То же самое при уничтожении персонажа.
Создайте класс MateriaSource, который должен будет реализовать следующий интерфейс:
learnMateria должна скопировать Materia, переданную в качестве параметра, и сохранить ее в памяти для последующего клонирования. Во многом так же, как и в случае с персонажем, Источник может знать максимум 4 Материи, которые не обязательно уникальны.
createMateria (std :: string const &) вернет новую Materia, которая будет копией Materia (ранее изученной источником), тип которой равен параметру.
Возвращает 0, если тип неизвестен. Короче говоря, ваш Источник должен уметь изучать «шаблоны» Материи и воссоздавать их по запросу. После этого вы сможете создать Материю, не зная ее "настоящего" типа,
просто строка, идентифицирующая его. Как обычно, вот основной тест, который вам нужно улучшить: